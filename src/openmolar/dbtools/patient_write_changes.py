# -*- coding: utf-8 -*-
# Copyright (c) 2009 Neil Wallace. All rights reserved.
# This program or module is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version. See the GNU General Public License
# for more details.

import logging
import MySQLdb,sys,types

from openmolar.connect import connect
from openmolar.settings import localsettings
from openmolar.dbtools import patient_class

BPE_INS_QUERY = '''insert into bpe (serialno, bpedate, bpe) 
values (%s, %s, %s) on duplicate key update bpe=%s'''

EXMPT_INS_QUERY = '''
insert into exemptions (serialno, exemption, exempttext, datestamp)
values (%s,%s,%s, NOW())'''

ESTS_INS_QUERY = '''insert into newestimates (serialno,
courseno, number, itemcode, description, fee, ptfee, feescale,
csetype, dent, completed, modified_by, time_stamp) values
(%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, NOW())'''


#couldn't get this query to play nice with mysql's last_insert_id()
#functionality !!
EST_LINK_INS_QUERY = '''
insert into est_link (est_id, tx_hash) values (LAST_INSERT_ID(), %s)'''

EST_DEL_QUERY = "delete from newestimates where ix=%s"

SYNOPSIS_INS_QUERY = '''
insert into clinical_memos (serialno, synopsis, author, datestamp) 
values (%s, %s, %s, NOW())'''

def all_changes(pt, changes):
    print "writing_changes to patient"
    if changes == []:
        print "write changes called, but no changes for patient %d"% (
        pt.serialno)

        return True
    else:

        #set up some booleans to prevent multiple updates of the same data
        #example exemption AND exemption text have changed..
        exemptionsHandled = False

        if pt.HIDDENNOTES != []:
            #-- hidden notes is
            #-- treatment codes... money, printing etc..
            print "saving hiddennotes"
            toNotes(pt.serialno, pt.HIDDENNOTES)
            pt.clearHiddenNotes()

        sqlcommands = {}
        patchanges, patvalues = "", []
        trtchanges, trtvalues = "", []
        for change in changes:
            if change == "courseno":
                pass #these values should never get munged.

            elif change in ("money0, money1"):
                diff = pt.__dict__[change] - pt.dbstate.__dict__[change]
                patvalues.append (diff)
                patchanges += '%s = %s + %%s,'% (change, change)

            elif change in patient_class.patientTableAtts:
                patvalues.append(pt.__dict__[change])
                patchanges += '%s = %%s,'% change

            elif (change in patient_class.exemptionTableAtts and
            not exemptionsHandled):
                values = (pt.serialno, pt.exemption, pt.exempttext)
                sqlcommands['exemptions'] = ((EXMPT_INS_QUERY, values),)
                exemptionsHandled = True

            elif change == "bpe":
                values = (  pt.serialno, 
                            pt.bpe[-1][0],
                            pt.bpe[-1][1], 
                            pt.bpe[-1][1]
                            )
                sqlcommands['bpe'] =((BPE_INS_QUERY, values),)

            elif change == "synopsis":
                values = (pt.serialno, pt.synopsis, 
                localsettings.operator)
                
                sqlcommands['clinical_memos']= ((SYNOPSIS_INS_QUERY, values),)

            elif change == "estimates":
                sqlcommands["estimates"]=[]
                oldEstDict={}
                if pt.courseno == pt.dbstate.courseno:
                    for est in  pt.dbstate.estimates:
                        #-- generate a dictionary with the 
                        #-- autogenerated db indexas key
                        if est.ix != None:
                            oldEstDict[est.ix] = est
                        
                for est in pt.estimates:
                    if est.ix == None: #--new item
                        values = (pt.serialno, pt.courseno, est.number, 
                        est.itemcode, est.description,
                        est.fee, est.ptfee, est.feescale, est.csetype,
                        est.dent, est.completed, localsettings.operator)

                        sqlcommands["estimates"].append(
                            (ESTS_INS_QUERY, values)
                            )

                        for tx_hash in est.tx_hashes:
                            values = (tx_hash,)
                            sqlcommands["estimates"].append(
                            (EST_LINK_INS_QUERY, values)
                            )

                    elif est.ix in oldEstDict.keys():
                        oldEst = oldEstDict[est.ix]

                        if str(oldEst) !=  str(est):
                            #-- have to use the str because est class does not
                            #-- have a _eq_ property ??
                            query = 'update newestimates set '
                            values = []
                            if oldEst.number != est.number:
                                query += "number=%s,"
                                values.append(est.number)
                            if oldEst.itemcode != est.itemcode:
                                query += 'itemcode=%s,'
                                values.append(est.itemcode)
                            if oldEst.description != est.description:
                                query += 'description=%s,'
                                values.append(est.description)
                            if oldEst.fee != est.fee:
                                query += 'fee=%s,'
                                values.append(est.fee)
                            if oldEst.ptfee != est.ptfee:
                                query += "ptfee=%s,"
                                values.append(est.ptfee)
                            if oldEst.feescale != est.feescale:
                                query += 'feescale=%s,'
                                values.append(pt.feescale)
                            if oldEst.csetype != est.csetype:
                                query += 'csetype=%s,'
                                values.append(est.csetype)
                            if oldEst.dent != est.dent:
                                query += 'dent=%d,'
                                values.append(est.dent)
                            if oldEst.completed != est.completed:
                                query += 'completed=%s,'
                                values.append(est.completed)
                            query += '''modified_by = %s,
                            time_stamp = NOW() where ix = %s'''

                            values.append(localsettings.operator)
                            values.append(est.ix)

                            sqlcommands["estimates"].append(
                            (query, tuple(values)),)

                        oldEstDict.pop(est.ix)
                #-- all that is left in oldEstDict now are items which
                #-- have been removed.
                #-- so remove from database also.
                for ix in oldEstDict.keys():
                    #--removed
                    values = (ix,)
                    sqlcommands["estimates"].append((EST_DEL_QUERY, values))

            elif change in patient_class.CURRTRT_ATTS:
                value = pt.__dict__[change]
                trtchanges += '%s = %%s ,'% change
                trtvalues.append(value)

            elif change == "appt_prefs":
                pt.appt_prefs.commit_changes()


    result=True
    if patchanges != "":
        patvalues.append(pt.serialno)
        values = tuple(patvalues)
        
        query = "update patients SET %s where serialno=%%s"% patchanges.strip(",")
        
        sqlcommands['patients'] = ((query, values),)
        
    if trtchanges != "":
        trtvalues.append(pt.serialno)
        trtvalues.append(pt.courseno)
        values = tuple(trtvalues)
        
        query = 'update currtrtmt2 SET %s where serialno=%%s and courseno=%%s'%(
            trtchanges.strip(","))
        sqlcommands['currtrtmt'] = ((query, values),)

    if sqlcommands != {}:
        db=connect()
        cursor = db.cursor()
        tables = sqlcommands.keys()
        for table in tables:
            for query, values in sqlcommands[table]:
                if "last_row_id" in values:
                    new_values = []
                    for value in values:
                        if value == "last_row_id":
                            new_values.append(cursor.lastrowid)
                        else:
                            new_values.append(value)
                    values = tuple(new_values)
                try:
                    cursor.execute(query, values)
                except Exception,e:
                    print query, values
                    logging.exception(
                        "error saving %s for patient %d"%(table, pt.serialno))
                    result = False
        cursor.close()
        db.commit()

        #db.close()
    return result

def toNotes(serialno, newnotes):
    '''
    new code with schema 1.9
    '''
    print "write changes - toNotes for patient %d"%serialno

    #database version stores max line length of 80chars

    query = '''insert into formatted_notes
    (serialno, ndate, op1, op2, ntype, note)
    VALUES (%s, DATE(NOW()), %s, %s, %s, %s)
    '''
    notetuplets = []

    tstamp = localsettings.currentTime().strftime("%d/%m/%Y %T")
    notetuplets.append(
        ("opened", "System date - %s"% tstamp))
    for ntype, note in newnotes:
        while len(note)>79:
            if " " in note[:79]:
                pos = note[:79].rindex(" ")
                #--try to split nicely
            elif "," in note[:79]:
                pos = note[:79].rindex(",")
                #--try to split nicely
            else:
                pos = 79
                #--ok, no option (unlikely to happen though)
            notetuplets.append((ntype, note[:pos]))
            note = note[pos+1:]

        notetuplets.append((ntype, note+"\n"))
    notetuplets.append(
        ("closed", "%s %s"% (localsettings.operator,tstamp)))

    values = []
    ops = localsettings.operator.split("/")
    op1 = ops[0]
    try:
        op2 = ops[1]
    except IndexError:
        op2 = None
    for ntype, noteline in notetuplets:
        values.append((serialno, op1, op2, ntype, noteline))

    rows = 0
    if values:
        db=connect()
        cursor = db.cursor()

        #this (superior code?) didn't work on older MySQLdb versions.
        #rows = cursor.executemany(query, tuple(values))
        for value in values:
            rows += cursor.execute(query, value)

        cursor.close()
        db.commit()

    return rows > 0


def discreet_changes(pt_changed,changes):
    '''
    this updates only the selected atts
    (usually called by automated proc such as recalls...
    and accounts) only updates the patients table
    '''
    print "write changes - discreet changes"

    sqlcond=""
    for change in changes:
        value=pt_changed.__dict__[change]
        print change,type(value)
        if change in patient_class.dateFields:
            if value != "" and value != None:
                sqlcond+='%s="%s" ,'%(change, value)
        elif value==None:
            sqlcond+='%s=NULL ,'%(change)
        elif (type(value) is types.IntType) or  (type(value) is types.LongType) :
            sqlcond+='%s=%s ,'%(change,value)
        else:
            sqlcond+='%s="%s" ,'%(change,value)

    print "update patients SET %s where serialno=%s"%(sqlcond.strip(","),
                                                      pt_changed.serialno)
    result=True
    if sqlcond != "":
        db=connect()
        cursor = db.cursor()
        #print cursor.execute(sqlcommand)
        try:
            sqlcommand= "update patients SET %s where serialno=%s"%(
                                    sqlcond.strip(","),pt_changed.serialno)

            cursor.execute(sqlcommand)
            db.commit()
        except Exception,e:
            print e
            result=False
        cursor.close()
        #db.close()
    return result
