# -*- coding: utf-8 -*-
# Copyright (c) 2009 Neil Wallace. All rights reserved.
# This program or module is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# See the GNU General Public License for more details.

'''
provides code to add Xrays, perio items......etc
to the treatment plan
'''

import re
import logging

from PyQt4 import QtGui, QtCore

from openmolar.settings import localsettings
from openmolar.ptModules.estimates import TXHash, Estimate

from openmolar.qt4gui.compiled_uis import Ui_customTreatment

from openmolar.qt4gui.dialogs.add_treatment_dialog import AddTreatmentDialog

from openmolar.qt4gui.fees import course_module
from openmolar.qt4gui.fees import complete_tx

from openmolar.qt4gui.charts import charts_gui

LOGGER = logging.getLogger("openmolar")

def offerTreatmentItems(om_gui, tx_list, completing=False):
    '''
    tx_list should be an iterable in the form ((att, shortcut),(att, shortcut))
    eg.(("perio", "SP-"),("xray", "S"), ("ul8", "MOD").... )
    these are offered to the user, who selects from these.
    the return value is an iterable in the same form.
    '''
    dl = AddTreatmentDialog(tx_list, om_gui.pt, om_gui)
    if completing: #we are adding to the completed treatments, not plan
        dl.use_completed_messages()
    result = dl.getInput()
    return result

def add_treatments_to_plan(om_gui, treatments, completed=False):
    LOGGER.debug(treatments)
    if course_module.newCourseNeeded(om_gui):
        return
    pt = om_gui.pt

    for att, shortcut in treatments:
        existing_txs = "%s %s"% (pt.treatment_course.__dict__["%scmp"% att] ,
            pt.treatment_course.__dict__["%spl"% att]
            )

        # count the existing number and add 1 for the new shortcut
        n_txs = existing_txs.split(" ").count(shortcut) + 1
        courseno = pt.treatment_course.courseno
        tx_hash = TXHash(hash("%s%s%s%s"% (courseno, att, n_txs, shortcut)))

        dentid = pt.course_dentist

        if (
        complex_shortcut_handled(om_gui, att, shortcut, n_txs, dentid, tx_hash)
        or
        add_treatment_to_estimate(om_gui, att, shortcut, dentid, [tx_hash])
        ):

            pt.treatment_course.__dict__["%spl"% att] += "%s "% shortcut

        if completed:
            complete_tx.tx_hash_complete(om_gui, tx_hash)

    om_gui.update_plan_est()

def add_treatment_to_estimate(om_gui, att, shortcut, dentid, tx_hashes,
    itemcode=None, csetype=None, descr=None,
    fee=None, ptfee=None, chosen_feescale=None):
    '''
    add an item to the patient's estimate
    usercode unnecessary if itemcode is provided.
    '''
    usercode = ("%s %s"% (att, shortcut))
    LOGGER.debug("%s %s %s %s %s %s %s %s %s"%(
        usercode, dentid, tx_hashes,
        itemcode, csetype, descr,
        fee, ptfee, chosen_feescale)
        )

    for tx_hash in tx_hashes:
        assert type(tx_hash) == TXHash, "bad form Neil"

    pt = om_gui.pt

    est = Estimate()
    est.ix = None #-- this will be generated by autoincrement on commit
    est.serialno = pt.serialno
    est.courseno = pt.courseno0

    if chosen_feescale == None:
        table = pt.getFeeTable()
    else:
        table = localsettings.FEETABLES.tables[feescale]

    if csetype is None:
        est.csetype = pt.cset
    else:
        est.csetype = csetype
    '''
        elif re.match("[ul][lr][1-8]$", att): # chart add

            #--tooth may be deciduous
            tooth_name = pt.chartgrid.get(att)
            ft = pt.getFeeTable()
            item = ft.get_tooth_fee_item(tooth_name, tx)
            if item:
                descr = item.description.replace("*",
                    " %s"% tooth_name.upper())

                add_treatment_to_estimate(om_gui,
                    att, tx, dentid, [tx_hash], item.itemcode, descr=descr)

            else:
                descr = "%s %s"% (_("Other treatment"), tooth_name)
                add_treatment_to_estimate(om_gui, att, tx, dentid, [tx_hash],
                "4001", descr=descr)
    '''

    if re.match("[ul][lr][1-8]", att):
        if itemcode is None:
            itemcode = table.getToothCode(att, shortcut)
        if descr is None:
            tooth_name = pt.chartgrid.get(att).upper()
            descr = table.getItemDescription(itemcode, usercode)
            descr = descr.replace("*", " %s"% tooth_name)
    else:
        if itemcode is None:
            itemcode = table.getItemCodeFromUserCode(usercode)
        if descr is None:
            descr = table.getItemDescription(itemcode, usercode)

    est.itemcode = itemcode
    est.description = descr

    if fee is None and ptfee is None:
        #look up the fee here
        est.fee, est.ptfee = table.getFees(itemcode, pt, est.csetype)
    else:
        est.fee, est.ptfee = fee, ptfee

    est.tx_hashes = tx_hashes

    est.dent = dentid

    inserted = False
    for i, existing_est in enumerate(pt.estimates):
        if existing_est.itemcode == est.itemcode:
            try:
                if pt.estimates[i+1].itemcode != est.itemcode:
                    pt.estimates.insert(i, est)
                    inserted = True
                    break
            except IndexError:
                pass

    if not inserted:
        pt.estimates.append(est)

    return True

def tx_planning_dialog_add_txs(om_gui, items, completed=False):
    LOGGER.debug(items)
    cust_items = []
    for item in items:
        if item[0] == "custom":
            cust_items.append(item)
    for item in cust_items:
        items.remove(item)
    add_treatments_to_plan(om_gui, items, completed)
    for att, shortcut in cust_items:
        customAdd(om_gui, shortcut)

def remove_treatments_from_plan(om_gui, treatments, completed=False):
    LOGGER.debug(treatments)
    pt = om_gui.pt
    courseno = pt.treatment_course.courseno
    for att, shortcut in treatments:
        if completed:
            txs = pt.treatment_course.__dict__["%scmp"% att]
        else:
            txs = "%s %s"% (
                pt.treatment_course.__dict__["%scmp"% att],
                pt.treatment_course.__dict__["%spl"% att]
                )

        n_txs = txs.split(" ").count(shortcut)
        hash_ = hash("%s%s%s%s"% (courseno, att, n_txs, shortcut))
        tx_hash = TXHash(hash_, completed)
        remove_tx_hash(om_gui, tx_hash)

        if re.match("[ul][lr[1-8]", att):
            plan = pt.treatment_course.__dict__["%spl"% att]
            cmp = pt.treatment_course.__dict__["%scmp"% att]
            charts_gui.updateChartsAfterTreatment(om_gui, att, plan, cmp)

def remove_tx_hash(om_gui, hash_):
    LOGGER.debug("removing tx_hash %s"% hash_)
    att_, tx = om_gui.pt.get_tx_from_hash(hash_)
    if att_ is None or tx is None:
        LOGGER.error("%s not found!"% hash_)
        om_gui.advise(u"%s %s"% (
        _("Couldn't find item in the patient's treatment plan"),
        _("This Shouldn't Happen!")), 2)

        return

    att = "%scmp"% att_ if hash_.completed else "%spl"% att_

    old_val = om_gui.pt.treatment_course.__dict__[att]
    new_val = old_val.replace("%s"% tx, "", 1)
    om_gui.pt.treatment_course.__dict__[att] = new_val
    LOGGER.debug(
    "updated pt.treatment_course.%s to from '%s' to '%s'"% (
    att, old_val, new_val))

    ests_altered = False
    for est in om_gui.pt.ests_from_hash(hash_):
        LOGGER.debug("removing reference to %s in estimate %s"% (
            hash_, est))
        est.tx_hashes.remove(hash_)
        if est.tx_hashes == []:
            om_gui.pt.estimates.remove(est)
        ests_altered = True

    if not ests_altered:
        om_gui.advise(u"%s %s"% (
        _("Couldn't find item in the patient's estimate"),
        _("This Shouldn't Happen!")), 2)

    return True

def tx_planning_dialog_delete_txs(om_gui, items, completed=False):
    '''
    these will be items such as (("perio", "SP"),). if completed, then the
    items have already been completed.
    '''
    LOGGER.debug("%s %s"% (items, completed))
    remove_treatments_from_plan(om_gui, items, completed)

def perioAdd(om_gui):
    '''
    add perio items
    '''
    pt = om_gui.pt

    if "N" in pt.cset:
        mylist = (
        ("perio", "SP"),
        )
    else:
        mylist = (
        ("perio", "SP-"),
        ("perio", "SP"),
        ("perio", "SP+"),
        )

    chosen_treatments = offerTreatmentItems(om_gui, mylist)
    add_treatments_to_plan(om_gui, chosen_treatments)

def xrayAdd(om_gui, complete=False):
    '''
    add xray items
    '''
    mylist = (
        ("xray", "S"),
        ("xray", "M"),
        ("xray", "P"),
        )
    #offerTreatmentItems is a generator, so the list conversion here
    #is so that the dialog get raised before the
    #"were these xrays taken today question
    chosen_treatments = list(offerTreatmentItems(om_gui, mylist, complete))

    if not chosen_treatments:
        return

    if not complete:
        input = QtGui.QMessageBox.question(om_gui, _("question"),
        _("Were these xrays taken today?"),
        QtGui.QMessageBox.No | QtGui.QMessageBox.Yes,
        QtGui.QMessageBox.No )
        if input == QtGui.QMessageBox.Yes:
            complete = True

    add_treatments_to_plan(om_gui, chosen_treatments)
    if om_gui.ui.tabWidget.currentIndex() == 4: #clinical summary
        om_gui.load_clinicalSummaryPage()

def otherAdd(om_gui):
    '''
    add 'other' items
    '''
    item_list = om_gui.pt.getFeeTable().other_shortcuts

    chosen_treatments = offerTreatmentItems(om_gui, item_list)
    if chosen_treatments:
       add_treatments_to_plan(om_gui, chosen_treatments)

def customAdd(om_gui, description=None):
    '''
    add 'custom' items
    '''
    if course_module.newCourseNeeded(om_gui):
        return

    pt = om_gui.pt
    courseno = pt.treatment_course.courseno
    Dialog = QtGui.QDialog(om_gui)
    dl = Ui_customTreatment.Ui_Dialog()
    dl.setupUi(Dialog)
    if description:
        dl.description_lineEdit.setText(description)
    if Dialog.exec_():
        no = dl.number_spinBox.value()
        descr = unicode(dl.description_lineEdit.text(), "ascii", "ignore")

        if descr == "":
            descr = "??"
        usercode = str (descr.replace(" ", "_"))[:20].upper()

        fee = int(dl.fee_doubleSpinBox.value() * 100)

        for i in range(no):
            pt.treatment_course.custompl += "%s "% usercode

            custom_txs = "%s %s"%(
                pt.treatment_course.customcmp, pt.treatment_course.custompl)
            n = custom_txs.split(" ").count(usercode)
            tx_hash = TXHash(hash("%scustom%s%s"% (courseno, n, usercode)))
            dentid = om_gui.pt.course_dentist

            add_treatment_to_estimate(om_gui, "custom", usercode, dentid,
            [tx_hash], itemcode="CUST", csetype="P",
            descr=descr, fee=fee, ptfee=fee)

        om_gui.update_plan_est()


def fromFeeTable(om_gui, fee_item, sub_index):
    '''
    add an item which has been selected from the fee table itself
    sub_index is when a child item has been added.
    '''
    LOGGER.debug("fee_item %s, sub_index %s"% (fee_item, sub_index))
    if not fee_item.allow_feescale_add:
        om_gui.advise(_("This item can not be added to a treatment plan "
        "using this method, sorry")
        ,1)
        return
    if course_module.newCourseNeeded(om_gui):
        return

    table = om_gui.pt.getFeeTable()

    if fee_item.table != table:
        table = confirmWrongFeeTable(om_gui, fee_item.table.index,
        table.index)

        if not table:
            return

    type_ = fee_item.pl_cmp_type
    if "CHART" in type_:
        update_charts_needed = True
        types = om_gui.chooseTooth()
    else:
        update_charts_needed = False
        types = [type_]

    usercode = fee_item.usercode
    itemcode = fee_item.itemcode
    fee = fee_item.fees[sub_index][0]

    if usercode == "":
        usercode = itemcode

    try:
        pt_fee = fee_item.ptFees[sub_index][0]
    except IndexError:
        pt_fee = fee

    for type_ in types:
        try:
            om_gui.pt.treatment_course.__dict__[type_+"pl"] += "%s "% usercode
            if update_charts_needed:
                om_gui.ui.planChartWidget.setToothProps(type_,
                om_gui.pt.treatment_course.__dict__[type_+"pl"])
        except KeyError, e:
            print "patient class has no attribute '%spl'" %type_,
            print "Will default to 'other'"
            om_gui.pt.treatment_course.otherpl += "%s "% usercode

        om_gui.pt.addToEstimate(1, itemcode, om_gui.pt.dnt1,
        category = type_, type_=usercode, feescale=table.index,
        fee=fee, ptfee=pt_fee)

    if om_gui.ui.tabWidget.currentIndex() != 7:
        om_gui.ui.tabWidget.setCurrentIndex(7)
    else:
        om_gui.update_plan_est()

    om_gui.advise(u"<b>%s</b> %s (%s)"% (
        fee_item.description, _("added to estimate"), _("from feescale"))
        ,1)

def confirmWrongFeeTable(om_gui, suggested, current):
    '''
    check that the user is happy to use the suggested table, not the current
    one. returns the selected table, or None to keep the current.
    '''
    suggestedTable = localsettings.FEETABLES.tables.get(suggested)
    currentTable = localsettings.FEETABLES.tables.get(current)
    message = '''<p>Confirm you wish to use the fee table <br />
    '%s - %s'<br /><br />
    and not the patient's current fee table <br />
    '%s - %s'<br /> for this item?</p>'''% (
    suggestedTable.tablename, suggestedTable.description,
    currentTable.tablename, currentTable.description)
    input = QtGui.QMessageBox.question(om_gui, "Confirm", message,
            QtGui.QMessageBox.No | QtGui.QMessageBox.Yes,
            QtGui.QMessageBox.No )
    if input == QtGui.QMessageBox.Yes:
        return suggestedTable

def complex_shortcut_handled(om_gui, att, shortcut, item_no, dentid, tx_hash):
    LOGGER.debug(
    "checking %s %s %s %s %s"% (att, shortcut, item_no, dentid, tx_hash))
    pt = om_gui.pt
    fee_table = pt.getFeeTable()
    LOGGER.debug("Feetable being checked = %s"% fee_table)
    for complex_shortcut in fee_table.complex_shortcuts:
        if complex_shortcut.matches(att, shortcut):
            LOGGER.debug("%s %s is a complex shortcut with %d cases"% (
            att, shortcut,len(complex_shortcut.cases)))

            for case in complex_shortcut.cases:
                condition_met = False
                m = re.match("n_txs=(\d+)", case.condition)
                m2 = re.match("n_txs>(\d+)", case.condition)

                if case.condition == "True":
                    condition_met = True
                elif m and int(m.groups()[0]) == item_no:
                    condition_met = True
                elif m2 and item_no > int(m2.groups()[0]):
                    condition_met = True

                if condition_met:
                    LOGGER.debug("condition met %s"% case.condition)
                    tx_hashes = [tx_hash]
                    for item_code in case.removals:
                        for est in pt.estimates:
                            if est.itemcode == item_code:
                                LOGGER.debug("removing estimate %s"% est)
                                pt.estimates.remove(est)
                                tx_hashes += est.tx_hashes

                    for item_code in case.additions:
                        LOGGER.debug("adding additional code %s"% item_code)
                        add_treatment_to_estimate(om_gui,
                        att, shortcut, dentid, tx_hashes, item_code)

                    for item_code in case.alterations:
                        #instead of adding a new estimate item
                        #add this treatment hash to existing item
                        LOGGER.debug("altering code %s"% item_code)
                        for est in pt.estimates:
                            if est.itemcode == item_code:
                                est.tx_hashes += tx_hashes
                                LOGGER.debug("est altered %s"% est)

                    if case.message != "":
                        om_gui.advise(case.message, 1)
                        LOGGER.info(case.message)

            LOGGER.info(
            "%s %s was handled by as a complex shortcut"% (att, shortcut))
            return True
    LOGGER.debug("%s not a complex shortcut"% shortcut)
    return False

def remove_estimate_item(om_gui, est_item):
    '''
    the estimate_item has been deleted...
    remove from the plan or completed also?
    '''
    LOGGER.debug("Apply treatment plan changes for %s"% est_item)

    pt = om_gui.pt
    found = False

    for i, tx_hash in enumerate(est_item.tx_hashes):
        LOGGER.debug("est_item.tx_hash %d = %s" %(i, tx_hash))
        for hash_, att, treat_code in pt.tx_hashes:
            #LOGGER.debug("comparing %s with %s"% (hash_, tx_hash))
            if hash_ == tx_hash.hash:
                found = True

                LOGGER.debug("       MATCHING hash Found!")

                if est_item.is_exam:
                    pt.treatment_course.examt = ""
                    pt.treatment_course.examd = None
                    pt.addHiddenNote("exam", treat_code, attempt_delete=True)
                    break

                old_completed = pt.treatment_course.__dict__[att + "cmp"]
                new_completed = old_completed.replace(treat_code, "", 1)

                old_plan = pt.treatment_course.__dict__[att + "pl"]
                new_plan = old_plan.replace(treat_code, "", 1)

                if tx_hash.completed:
                    attribute = att + "cmp"
                    LOGGER.debug("%s old = '%s' new = '%s'"% (
                        attribute, old_completed, new_completed))

                    pt.treatment_course.__dict__[attribute] = new_completed

                    if re.match("[ul][lr][1-8]", att):
                        charts_gui.updateChartsAfterTreatment(
                            om_gui, att, plan, completed)
                        toothName = pt.chartgrid.get(att,"").upper()
                        pt.addHiddenNote("chart_treatment",
                            "%s %s"% (toothName, treat_code),
                            attempt_delete=True)
                    elif att in ("xray", "perio"):
                        pt.addHiddenNote("%s_treatment"%att,
                            treat_code,
                            attempt_delete=True)
                    else:
                        pt.addHiddenNote("treatment",
                            treat_code,
                            attempt_delete=True)
                else:
                    attribute = att + "pl"
                    LOGGER.debug("%s old = '%s' new = '%s'"% (
                        attribute, old_plan, new_plan))

                    pt.treatment_course.__dict__[attribute] = new_plan


    if not found:
        LOGGER.debug("NO MATCHING hash FOUND!")
        om_gui.advise (u"%s - %s"%(
        _("couldn't pass on delete message for"), est_item.description)
        , 1)

    om_gui.updateHiddenNotesLabel()


def recalculate_estimate(om_gui):
    '''
    look up all the itemcodes in the patients feetable
    (which could have changed), and apply new fees
    '''
    pt = om_gui.pt
    dentid = pt.course_dentist

    #drop all existing estimates except custom items.
    #and reverse fee for completed items.
    cust_ests = []
    for estimate in pt.estimates:
        if estimate.is_custom:
            cust_ests.append(estimate)
    pt.estimates = cust_ests

    duplicate_txs = []

    for hash_, att, tx in pt.tx_hashes:
        tx = tx.strip(" ")

        tx_hash = TXHash(hash_)

        duplicate_txs.append("%s%s"%(att, tx))
        item_no = duplicate_txs.count("%s%s"%(att, tx))

        if att == "custom":
            pass

        else:
            if not complex_shortcut_handled(om_gui, att, tx,
            item_no, dentid, tx_hash):
                add_treatment_to_estimate(om_gui, att, tx, dentid, [tx_hash])

    LOGGER.debug("checking for completed items")
    for est in pt.estimates:
        for tx_hash in est.tx_hashes:
            for hash_, att, tx in pt.completed_tx_hashes:
                if tx_hash == hash_:
                    tx_hash.completed = True

    return True


if __name__ == "__main__":
    #-- test code

    localsettings.initiate()
    localsettings.loadFeeTables()
    localsettings.station="reception"

    from openmolar.qt4gui import maingui
    from openmolar.dbtools import patient_class
    LOGGER.setLevel(logging.DEBUG)

    app = QtGui.QApplication([])
    mw = maingui.OpenmolarGui()
    mw.getrecord(11956)
    #disable the functions called
    mw.load_newEstPage = lambda : None

    xrayAdd(mw)
    perioAdd(mw)
    otherAdd(mw)
    customAdd(mw)
